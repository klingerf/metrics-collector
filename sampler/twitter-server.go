package sampler

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"regexp"
	"time"
)

type TwitterServerSampler struct {
	MetricsURL string
	matcher    *regexp.Regexp
}

var (
	rtRequest = regexp.MustCompile(`^rt/.*/(requests|success)$`)
	rtLatency = regexp.MustCompile(`^rt/.*/request_latency_ms\.(p50|p99)$`)
	jvmStat   = regexp.MustCompile(`^jvm/uptime$`) // just uptime, for now
)

func NewTwitterServerSampler(metricsURL, matchRegexp string) *TwitterServerSampler {
	var matcher *regexp.Regexp
	if len(matchRegexp) > 0 {
		matcher = regexp.MustCompile(matchRegexp)
	}

	return &TwitterServerSampler{metricsURL, matcher}
}

func (sampler TwitterServerSampler) Sample() (*Sample, error) {
	earliest := time.Now().Unix()
	rsp, err := http.Get(sampler.MetricsURL)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}

	metrics := make(Metrics)
	err = json.Unmarshal(body, &metrics)
	if err != nil {
		return nil, err
	}

	return &Sample{metrics, earliest}, nil
}

// Optionally trim the set of metrics down to a more reasonable size. Note that
// trimming metrics in this manner only really applies to metrics that were
// generated by a linkerd process.
func (sampler TwitterServerSampler) Trim(sample *Sample) {
	trimmed := make(Metrics)
	for k, v := range sample.Metrics {
		if rtRequest.MatchString(k) || rtLatency.MatchString(k) || jvmStat.MatchString(k) || (sampler.matcher != nil && sampler.matcher.MatchString(k)) {
			trimmed[k] = v
		}
	}
	sample.Metrics = trimmed
}
